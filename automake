#!/usr/bin/env python

import time
import os
from subprocess import PIPE, CalledProcessError, check_output
watchdog_imported = False
try:
  from watchdog.observers import Observer
  from watchdog.events import FileSystemEventHandler
  watchdog_imported = True
except ImportError:
  pass

def printmsg(msg):
  print('automake: %s' % msg)

class AutomakeEventHandler(FileSystemEventHandler):
  def __init__(self, command, sources, debug):
    self.__command = str(command)
    self.__debug = debug
    self.__source_files = self.__get_source_files(sources)
    self.__source_dirs = self.__get_source_dirs(sources)
    self()

  def __get_source_files(self, sources):
    source_files = [s for s in sources if os.path.isfile(s)]
    if source_files and self.__debug:
      printmsg('Watched files: %s' % source_files)
    return source_files

  def __get_source_dirs(self, sources):
    source_dirs = [s for s in sources if os.path.isdir(s)]
    if source_dirs and self.__debug:
      printmsg('Watched directories : %s' % source_dirs)
    return source_dirs

  def __call__(self):
    args = ['make', self.__command]
    printmsg('Calling: %s' % args)
    try:
      check_output(args, stdin=PIPE)
    except CalledProcessError as e:
      printmsg('Failure: %s' % e)

  def __is_watched(self, src_path):
    ret = False
    if os.path.exists(src_path):
      ret |= any([os.path.samefile(src_path, s) for s in self.__source_files])
      ret |= any([s in src_path for s in self.__source_dirs])
    return ret

  def on_any_event(self, event):
    if self.__debug:
      printmsg(event)
    if self.__is_watched(event.src_path):
      self()

class MakefileParser(object):
  def __init__(self, filename='Makefile', debug=False):
    self.__sources = []
    self.__variables = {}
    self.__debug = debug
    self.__parse(filename)
    self.__expand_variables()

  @property
  def sources(self):
    return self.__sources

  def __parse(self, filename):
    if os.path.exists(filename):
      with open(filename, 'r') as f:
        for line in f.readlines():
          if ':' in line:
            self.__sources.extend(line.split(':')[1].split())
          if '=' in line:
            k, v = line.split('=')
            self.__variables[k] = v.strip()
      self.__sources = [s.strip() for s in self.__sources]
      if self.__debug:
        printmsg('Parsed sources: %s' % self.__sources)
        printmsg('Parsed variables: %s' % self.__variables)
    else:
      raise RuntimeError('%s not found.' % filename)

  def __expand_variables(self):
    for i in range(len(self.__sources)):
      for k, v in self.__variables.items():
        self.__sources[i] = self.__sources[i].replace('${%s}' % k, v)
    if self.__debug:
      printmsg('Expanded variables: %s' % self.__sources)

def automake(args):
  parser = MakefileParser(debug=args.debug)
  event_handler = AutomakeEventHandler(args.cmd, parser.sources, args.debug)
  observer = Observer()
  observer.schedule(event_handler, '.', recursive=True)
  observer.start()
  try:
      while True:
          time.sleep(1)
  except KeyboardInterrupt:
      observer.stop()
  observer.join()

if __name__ == '__main__':
  import argparse
  parser = argparse.ArgumentParser(description='Runs make automatically on source file change.')
  parser.add_argument('--cmd', default='all', help='make command (default "%(default)s")')
  parser.add_argument('--debug', action='store_true', help='Run in debug mode.')
  args = parser.parse_args()
  if watchdog_imported:
    try:
      automake(args)
    except RuntimeError as e:
      printmsg(e)
  else:
    printmsg('Watchdog not available, please install it using pip: pip install watchdog')
    printmsg('See https://pythonhosted.org/watchdog/ if you encounter any installation problems.')
