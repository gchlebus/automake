#!/usr/bin/env python

DEBUG = False

import time
import os
from subprocess import PIPE, CalledProcessError, check_output
WATCHDOG_IMPORTED = False
try:
  from watchdog.observers import Observer
  from watchdog.events import FileSystemEventHandler
  WATCHDOG_IMPORTED = True
except ImportError:
  pass

def printmsg(msg):
  print('automake: %s' % msg)

class AutomakeEventHandler(FileSystemEventHandler):
  def __init__(self, makefilename, target):
    self.makefilename = makefilename
    self.target = target
    self.init()

  def __call__(self):
    args = ['make', self.target]
    printmsg('Calling: %s' % ' '.join(args))
    try:
      check_output(args, stdin=PIPE)
    except CalledProcessError as e:
      printmsg('Failure: %s' % e)

  def on_any_event(self, event):
    if DEBUG:
      printmsg(event)
    if self.is_watched(event.src_path):
      self()
    elif self.is_makefile(event.src_path):
      if DEBUG:
        printmsg('Makefile change detected.')
      self.init()

  def init(self):
    parser = MakefileParser(self.makefilename, self.target)
    self.watched_files = self.get_files(parser.prerequisites)
    self.watched_dirs = self.get_dirs(parser.prerequisites)
    self()

  def get_files(self, path_list):
    files = [p for p in path_list if os.path.isfile(p)]
    if files and DEBUG:
      printmsg('Watched files: %s' % ', '.join(files))
    return files

  def get_dirs(self, path_list):
    dirs = [p for p in path_list if os.path.isdir(p)]
    if dirs and DEBUG:
      printmsg('Watched directories : %s' % ', '.join(dirs))
    return dirs

  def is_watched(self, src_path):
    ret = False
    if os.path.exists(src_path):
      ret |= any([os.path.samefile(src_path, s) for s in self.watched_files])
      ret |= any([s in src_path for s in self.watched_dirs])
    return ret

  def is_makefile(self, src_path):
    if os.path.exists(src_path):
      return os.path.samefile(self.makefilename, src_path)
    return False

class MakefileParser(object):
  def __init__(self, makefilename, target='all'):
    self.targets = {}
    self.variables = {}
    self.parse(makefilename)
    if target not in self.targets:
      raise RuntimeError('Target %s not found.' % target)
    self.expand_variables()
    self.prerequisites = self.resolve_dependencies(target)

  def parse(self, filename):
    if os.path.exists(filename):
      with open(filename, 'r') as f:
        for line in f.readlines():
          if ':' in line:
            target, prerequisites = line.split(':')
            self.targets[target.strip()] = prerequisites.strip().split()
          if '=' in line:
            k, v = line.split('=')
            self.variables[k] = v.strip()
      if DEBUG:
        self.debug_print(print_variables=True)
    else:
      raise RuntimeError('%s not found.' % filename)

  def expand_variables(self):
    for target, prerequisites in self.targets.items():
      for i in range(len(prerequisites)):
        for varname, value in self.variables.items():
          self.targets[target][i] = self.targets[target][i].replace('${%s}' % varname, value)
    if DEBUG:
      self.debug_print()

  def resolve_dependencies(self, target):
    prerequisites = []
    for p in self.targets[target]:
      if p in self.targets:
        prerequisites.extend(self.resolve_dependencies(p))
      else:
        prerequisites.append(p)
    return prerequisites

  def debug_print(self, print_variables=False):
    if self.targets:
      printmsg('Targets:')
      for target, prerequisites in self.targets.items():
        printmsg('  %s: %s' % (target, ', '.join(prerequisites)))
    else:
      printmsg('No targets.')
    if print_variables:
      if self.variables:
        printmsg('Variables:')
        for varname, value in self.variables.items():
          printmsg('  %s: %s' % (varname, value))
      else:
        printmsg('No variables.')


def automake(args):
  event_handler = AutomakeEventHandler(args.makefilename, args.target)
  observer = Observer()
  observer.schedule(event_handler, '.', recursive=True)
  observer.start()
  try:
      while True:
          time.sleep(1)
  except KeyboardInterrupt:
      observer.stop()
  observer.join()

if __name__ == '__main__':
  import argparse
  parser = argparse.ArgumentParser(description='Runs make automatically on source files change.')
  parser.add_argument('--makefilename', default='Makefile', help='Name of the makefile (default "%(default)s")')
  parser.add_argument('--target', default='all', help='Make target (default "%(default)s")')
  parser.add_argument('--debug', action='store_true', help='Run in debug mode.')
  args = parser.parse_args()
  DEBUG = args.debug
  if WATCHDOG_IMPORTED:
    try:
      automake(args)
    except RuntimeError as e:
      printmsg(e)
  else:
    printmsg('Watchdog not available, please install it using pip: pip install watchdog')
    printmsg('See https://pythonhosted.org/watchdog/ if you encounter any installation problems.')
